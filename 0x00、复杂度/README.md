## 一、如何分析、统计算法的执行效率和资源消耗？

> 数据结构和算法本身解决的是「快」和「省」的问题，即如何让代码运行得更快，如何让代码更省存储空间。执行效率是算法非常重要的考量指标。所以引入`时间、空间复杂度`分析来衡量执行效率。

### 1、为什么需要复杂度分析

我们可以通过统计、监控来得到算法执行的时间和占用的内存大小，这种方法叫做`事后统计法`。但是这种方法有很大的局限性，例如：

1. **测试结果非常依赖测试环境。**

	测试环境中硬件不同或有很大影响，例如：同一段代码在 i9 处理器和 i3 处理器上运行。

2. **测试结果受数据规模影响很大。**

<font color=orange>所以我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</font>

### 2、大 O 复杂度表示法

这里有段非常简单的代码，求 1,2,3…n 的累加和。通过这段代码来估算一下这段代码的执行时间。

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  for (; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

假设每行代码执行的时间都一样，为 `unit_time`，第 2、3 行代码分别需要 1 个 ``unit_time`` 的执行时间；第 4、5 行都运行了 n 遍，所以需要 `2n * unit_time` 的执行时间。所以这段代码总的执行时间就是 **(2n+2) * unit_time**。

另一段代码：

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  int j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum = sum +  i * j;
    }
  }
}
```

依旧假设每个语句的执行时间是 unit_time。第 2、3、4 行代码，每行都需要 1 个 `unit_time` 的执行时间；第 5、6 行代码循环执行了 n 遍，需要 `2n * unit_time` 的执行时间；第 7、8 行代码循环执行了 n^2^，所以需要 2n^2^ * unit_time 的执行时间。所以这段代码总的执行时间 **T(n) = (2n^2^+2n+3) * unit_time**。

尽管我们不知道 `unit_time` 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。**我们可以把这个规律总结成一个公式：

$T(n)=O(f(n))$

> - T(n)：表示代码执行的时间；
> - n：表示数据规模的大小；
> - f(n)：表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。
> - O：表示代码的执行时间 T(n) 与 f(n) 表达式成正比

这就是大 O 时间复杂度表示法。它表示的不是具体的代码执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，所以也叫做**渐进时间复杂度**，简称**时间复杂度**。

### 3、时间复杂度分析

**（1）只关注循环执行次数最多的一段代码**

```c
int cal(int n) {
  int sum = 0;
  int i = 1;
  for (; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

第 2、3  行都是常量级的执行时间，与 n 大小无关。循环次数最多的就是第4、5 行代码，执行了 n 次，所以时间复杂度就是O(n)。

**（2）加法法则：总复杂度等于量级最大的那段代码的复杂度**

```c
int cal(int n) {
  
  int sum_1 = 0;
  int p = 1;
  for (; p < 100; ++p) {
    sum_1 = sum_1 + p;
  }

  int sum_2 = 0;
  int q = 1;
  for (; q < n; ++q) {
    sum_2 = sum_2 + q;
  }

  int sum_3 = 0;
  int i = 1;
  int j = 1;
  for (; i <= n; ++i) {
    j = 1; 
    for (; j <= n; ++j) {
      sum_3 = sum_3 +  i * j;
    }
  }
  return sum_1 + sum_2 + sum_3;
}
```

这段代码分三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析这三部分的时间复杂度，再取一个量级最大的作为整段代码的复杂度。

- 第一段 sum_1：这段代码循环了一百次，是**常量的执行时间**，与 n 的规模无关。
- 第二段 sum_2：时间复杂度 O(n)
- 第三段 sum_3：时间复杂度 O(n^2^)

综合这三段代码，取其中的最大量级，可以得出整段代码的时间复杂度是 O(n^2^)。抽象成公式就是：

如果 $T1(n)=O(f(n))$，$T2(n)=O(g(n))$；那么$T(n)=T1(n)+T2(n)=O(max(f(n),g(n)))$。

**（3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

```c
int cal(int n) {
  int ret = 0; 
  int i = 1;
  for (; i < n; ++i) {
    ret = ret + f(i);
  } 
  return ret;
} 

int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
}
```

如果我们单独看`cal()` ，则它第 4～6 行的的时间复杂度 $T1(n)=O(n)$；而在它第 4～6 行又调用了 `f()`，而 `f()`的时间复杂度又是 $T2(n) =O(n)$。所以总的来看`cal()` 的时间复杂度就是：$T(n)=T1(n)*T2(n)=O(n*n)=O(n^2)$。抽象成公式就是：

如果 $T1(n)=O(f(n))$，$T2(n)=O(g(n))$；那么$T(n)=T1(n)*T2(n)=O(f(n)*g(n))$。

### 4、几种常见时间复杂度实例分析

<img src="https://tva1.sinaimg.cn/large/0082zybply1gbv68gylkcj30oe0lggnw.jpg" alt="newname2020-02-1323.04.20" style="zoom:50%;" />

**（1）非多项式量级**

我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

**（2）多项式量级**

- **O(1)**

	1. O(1) 只是常量级时间复杂度的一种方法，不代表只执行了一行代码。
	2. O(1) 不随 n 的增大而增长，一般情况下，只要算法中不存在循环语句、递归语句，这样的代码时间复杂度都记做 O(1)。

- **O(logn)、O(nlogn)**

	```c
	i=1;
	while (i <= n)  {
	  i = i * 2;
	}
	```

	从代码可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2，当 i 大于 n 时，循环结束。实际上 i 的取值是一个等比数列 $2^0 \cdot2^1\cdot2^2\cdot\cdot\cdot\cdot2^x$，我们只需要求解出 x 就可以知道执行代码的次数，即 $x=log_2n$ ，所以这段代码的时间复杂度就是 $O(log_2n)$。

	```c
	i=1;
	while (i <= n)  {
	  i = i * 3;
	}
	```

	可以得出这段代码时间复杂度为 $O(log_3n)$。

	根据对数的换底公式 $log_ab=\frac{log_ca}{log_cb}$ ，可以得出 $log_3n=log_32\cdot log_2n$ ，$log_32$ 是常数可以忽略，所以我们可以得出结论：**在采用大 O 标记复杂度的时候，可以忽略系数**，即 $O(Cf(n)) = O(f(n))$。

	

	如果一段代码的时间复杂度是$ O(logn)$，我们循环执行 n 遍，时间复杂度就是 $O(nlogn)$了。而且，$O(nlogn)$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $O(nlogn)$。

- **O(m+n)、O(m*n)**

	```c
	int cal(int m, int n) {
	  int sum_1 = 0;
	  int i = 1;
	  for (; i < m; ++i) {
	    sum_1 = sum_1 + i;
	  }
	
	  int sum_2 = 0;
	  int j = 1;
	  for (; j < n; ++j) {
	    sum_2 = sum_2 + j;
	  }
	
	  return sum_1 + sum_2;
	}
	```

代码的复杂度由**两个数据**的规模来决定，这个时候我们就没法省略，所以上述代码时间复杂度为 $O(m+n)$。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：$T1(m) + T2(n) = O(f(m) + g(n))$。但是乘法法则继续有效：$T1(m)*T2(n) = O(f(m) * f(n))$。

### 5、空间复杂度

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。